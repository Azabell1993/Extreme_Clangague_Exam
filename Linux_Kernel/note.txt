    /*
        커널 개발
        --------
        추후에 커널 개발자나 보안 연구자가 되기 위해서 기록
        2022년 11월 14일
        박지우
    */

    /*
        커널 개발은 여러 측면에서 일반적인 C프로그램과 많이 다르다. 지금까지 공부해온 C의 개발은 사용자 공간에서 진행이 되어왔다..

        1. 단 하나의 커널 프로세스가 모든 것을 실행한다.
            커널에서 코드가 충돌이 발생한다면 머신을 재시작해서 커널을 다시 초기화해야 한다는 의미다.
            커널 프로세스의 개발 비용이 매우 많이 든다. 커널에 충돌이 발생하면 Knernel crash dump가 생성되며 이는 문제 원인 진단에 사용을 할 수 있다.

        2. 커널 링에는 glibc와 같은 C 표준 라이브러리가 없다. 즉, 커널 링은 SUS나 POSIX 표준이 더 이상 유효하지 않은 영역이라는 의미다.
            그러므로 stdio.h나 string.h와 같은 libc 헤더 파일을 포함할 수 없다.
            이들 함수는 일반적으로 커널 헤더에 있으며, 이 영역은 표준화되어 있지 않으므로 유닉스 버전마다 함수가 다를 수 있다.
            예를 들어 리눅스에서 커널을 개발할 경우, 커널 메시지 버퍼에 메시지를 작성하기 위해 printk를 사용할 수 있으나
            FreeBSD에서는 printf 함수군을 사용해야 하며 이는 libc의 printf 함수와는 다르다.
           FreeBSD 시스템에서는 <sys/system.h> 헤더 파일에서 printf 함수를 찾을 수 있다.
            XNU 커널 개발의 경우에는 해당 함수에 해당하는 것을 찾으면 os_log가 있다. (MacOS)
        3. 커널에서 파일을 읽거나 수정할 수는 있지만, libc 함수를 사용할 수는 없다. 각 유닉스 커널은 커널링 내부에 고유의 접근 파일에 대한 메서드가 있다.
            이는 libc에서 노출하는 모든 기능과 같다.
        4. 커널 링에서는 물리 메모리 및 다른 서비스에 완전히 접근할 수 있다. (안전하며 신뢰할 수 있는 코드가 매우 중요하다.)
        5. 커널에는 시스템 호출 메커니즘이 없다. 시스템 호출은 사용자 프로세스가 커널 링과 통신할 수 있도록 하는 주요 사용자 공간 메커니즘이다.
            (일단 커널에 들어가면 시스템 호출을 할 필요가 없다.)
        6. 커널 프로세스는 커널 이미지를 물리 메모리로 복제해 생성하고, 이는 부트로더가 수행한다. 맨 처음부터 커널 이미지를 생성한 다음 시스템을
            재부팅해서 시스템 호출을 다시 로드하지 않으면 새로운 시스템 호출을 추가할 수 없다.
    */

    /*
        일반적인 C개발과 흐름이 정말 많이 다르다.
        작성한 로직을 검사하기 쉽지 않고, 버그가 있는 코드는 시스템 충돌을 야기시킬 수 있을 것이다.
    */


    단일 작업을 이용해 작동하는 서버 프로그램

    의사코드

    계산기 서버 {
        작업 T1 {
            1. N = 0
            2. 서버 준비
            3. 영원히 수행 {
                4. 클라이언트 C를 기다리기
                5.  N += 1;
                6.  mov         dword ptr [a],0Ah
                7.  mov         dword ptr [b],14h
                8.  mov         eax,dword ptr [b]
                9.  mov         ecx,dword ptr [a]
                10. add         ecx,eax
                11. mov         eax,ecx
                12. Z = X + Y
                13. Z를 C에 쓰기
                14. C에 대한 연결을 종료
                15. N을 파일에 쓰기 (write)
            }
        }
    }

다중 작업 (멀티태스킹) 운영체제는 커널에 작업 스케줄러 유닛이 있어야한다.



Calculator Server {
    Value : N

    Work T1 {
        N=0
        setting.server
        Spon(T2)
        while {
            write.file(N)
            deleay(30s)
        }
    }

    Work T2 {
        while {
            Client(C_langague)
            N = N + 1
            Spon at work T3
        }
    }

    Work T3 {
        addValue(C.X)
        addValue(C.Y)
        Z = X + Y
        Z -> write(C)
        end(connector(C))
    }
}

